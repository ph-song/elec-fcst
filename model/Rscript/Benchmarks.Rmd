---
title: "Untitled"
author: "YUANJI JIN"
date: "2023-08-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(forecast)
library(fpp3)
feb01 <- read.csv("Actuals_Feb 01 8AM.csv")
feb02 <- read.csv("Actuals_Feb 02 8AM.csv")
feb03 <- read.csv("Actuals_Feb 03 8AM.csv")
feb04 <- read.csv("Actuals_Feb 04 8AM.csv")
feb05 <- read.csv("Actuals_Feb 05 8AM.csv")
feb06 <- read.csv("Actuals_Feb 06 8AM.csv")
feb07 <- read.csv("Actuals_Feb 07 8AM.csv")
feb08 <- read.csv("Actuals_Feb 08 8AM.csv")
feb09 <- read.csv("Actuals_Feb 09 8AM.csv")
feb10 <- read.csv("Actuals_Feb 10 8AM.csv")
feb11 <- read.csv("Actuals_Feb 11 8AM.csv")
feb12 <- read.csv("Actuals_Feb 12 8AM.csv")
feb13 <- read.csv("Actuals_Feb 13 8AM.csv")
feb14 <- read.csv("Actuals_Feb 14 8AM.csv")
feb15 <- read.csv("Actuals_Feb 15 8AM.csv")

# Remove rows with NAs for the January files
list_of_dfs <- list(feb01, feb02, feb03, feb04, feb05, feb06, feb07, feb08, feb09, feb10, feb11, feb12, feb13, feb14, feb15)
list_of_dfs <- lapply(list_of_dfs, function(x) x %>% filter_all(all_vars(!is.na(.))))

data <- read.csv("./data/cleaned_actual.csv")

# Set column names for all the jan dataframes
list_of_dfs <- list(feb01, feb02, feb03, feb04, feb05, feb06, feb07, feb08, feb09, feb10, feb11, feb12, feb13, feb14, feb15)

# Extract column names from df1
training_data_colnames <- colnames(training_data)

# Apply df1's column names to all the jan dataframes
list_of_dfs <- lapply(list_of_dfs, function(training_data) {
  colnames(training_data) <- training_data_colnames
  return(training_data)
})

# Convert Time column to POSIXct for all other dataframes
list_of_dfs <- lapply(list_of_dfs, function(x) {
  x$Time <- as.POSIXct(x$Time, format="%Y-%m-%d %H:%M", tz="UTC")
  return(x)
})

test_data <- rbind(do.call(rbind, list_of_dfs))

training_data$Time <- as.POSIXct(training_data$Time, format="%Y-%m-%d %H:%M", tz="UTC")

whole_data <- rbind(training_data, test_data)
```

```{r}

whole_data <- whole_data %>%
  arrange(Time) %>%
  mutate(across(-Time, list(lag_48 = ~ lag(.x, 168)), .names = "lag48_{col}"))


# Define MAE function for seasonal naive method
seasonal_naive_forecast <- function(train, lag) {
  forecast_values <- tail(train$Load..kW., lag)
  return(forecast_values)
}

# Naive Forecasting Function
naive_forecast <- function(train) {
  return(rep(tail(train$Load..kW., 1), roll_size))
}

# Random Walk with Drift Forecasting Function
random_walk_with_drift_forecast <- function(train) {
  last_value <- tail(train$Load..kW., 1)
  avg_change <- mean(diff(train$Load..kW.))
  return(last_value + avg_change * (1:roll_size))
}


# Rolling forecast parameters
roll_size <- 24 # 24 hours
end_of_train_data <- which(whole_data$Time == "2021-01-31 07:00:00")
start_test <- which(whole_data$Time == "2021-01-31 08:00:00")
end_data <- which(whole_data$Time == "2021-02-15 07:00:00")

mae_list <- list()

while((start_test + roll_size - 1) <= end_data) {
  set.seed(666)
  # Subset the training data (last two years from the current testing point)
  train_subset <- whole_data[(end_of_train_data - 2*365*24 + 1):end_of_train_data, ]
  test_subset <- whole_data[start_test:(start_test + roll_size - 1), ]
  
  # Calculate MAEs for the forecasting methods
  daily_forecast <- seasonal_naive_forecast(train_subset, 48)
  weekly_forecast <- seasonal_naive_forecast(train_subset, 24 * 7)
  monthly_forecast <- seasonal_naive_forecast(train_subset, 24 * 30) # Approximate
  yearly_forecast <- seasonal_naive_forecast(train_subset, 24 * 365) # Approximate
  naive_preds <- naive_forecast(train_subset)
  random_walk_with_drift_preds <- random_walk_with_drift_forecast(train_subset)
  
  daily_mae <- mean(abs(test_subset$Load..kW. - daily_forecast))
  weekly_mae <- mean(abs(test_subset$Load..kW. - weekly_forecast))
  monthly_mae <- mean(abs(test_subset$Load..kW. - monthly_forecast))
  yearly_mae <- mean(abs(test_subset$Load..kW. - yearly_forecast))
  naive_mae <- mean(abs(test_subset$Load..kW. - naive_preds))
  random_walk_with_drift_mae <- mean(abs(test_subset$Load..kW. - random_walk_with_drift_preds))
  
  
 
  # Roll forward by 48 hours in the test data
  start_test <- start_test + roll_size
  end_of_train_data <- end_of_train_data + roll_size
  
   mae_list[[paste0("Start_", as.character(whole_data$Time[start_test]))]] <- c(daily_mae, weekly_mae, monthly_mae, yearly_mae, naive_mae, random_walk_with_drift_mae)
}

# Convert the results list to a data frame
df_mae <- do.call(rbind.data.frame, mae_list)


colnames(df_mae) <- c("48 Hours Seasonal Naive", "Weekly Seasonal Naive", "Monthly Seasonal Naive", "Yearly Seasonal Naive", "Naive Last Value", "RandomWalkWithDrift")

avg_mae <- data.frame(Method = names(colMeans(df_mae)), Average_MAE = as.vector(colMeans(df_mae)))

# Sorting the avg_mae dataframe by Average_MAE in ascending order
sorted_avg_mae <- avg_mae %>% arrange(Average_MAE)

sorted_avg_mae
```

# 


